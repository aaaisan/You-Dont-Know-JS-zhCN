# You Don't Know JS: Async & Performance
# Chapter 2: Callbacks

（本来英文就差，这一章翻的好吃力，感觉在讲大脑原理与异步编码的关系之类的论文……—_—已猝。）

在第1章，我们探索了JS编程里的异步概念。我们着重于理解单线程下的事件轮询队列驱动事件（异步函数调用）。我们也探索了不同并发模式，它们解释了*同步*事件运行链和“进程”（任务、函数调用等）的关系。

第1章的所有例子都使用函数作为个人的最小的的操作单元，即函数中的语句是按照预期的顺序执行（编译器级别的上一层），但是在函数顺序级别，事件（即异步函数调用）发生的顺序是可变的。

在所有的场景下，函数被作为一个“回调”，因为它的角色是事件轮训“召回”到程序里的目标，只要它在队列里就会被处理。

你也确实看到了，回调是目前为止JS编程里最普通的异步表达和管理方式，的确，回调是这门语言里大多数异步模式的基础。

无数JS程序，即使是精细又复杂的那些，也都是把回调当作异步基础的（当然包括我们在第1章里探索的并发交互模式），回调函数是JS异步主力，并且工作的很好。

除了……回调并不是没有缺点，许多开发者激动于更好的异步模式*promises*（双关语！），但是如果你不理解它的概念和原理你不能有效的使用任何概念。

这一章，我们会深入探索其中几个，从而解释为何更成熟的异步模式是必要的。

## Continuations

我们回到第1章开始的异步回调例子，为了突出一点，我稍微修改了一下：

```js
// A
ajax( "..", function(..){
	// C
} );
// B
```

`// A`和`// B`代表程序的第一部分（即*当前*），`//C`代表程序的第二部分（即*后来*）。第一部分立刻执行，然后中间有一段“暂停”，未来某时刻，如果Ajax调用有了响应，那么程序会从刚才暂停的地方*继续*完成第二部分的执行。

换句话说，回调函数包裹或封装了*继续*程序，我们让代码更简单一些：

```js
// A
setTimeout( function(){
	// C
}, 1000 );
// B
```

停下来想一想，你会如何（给那些对JS运行原理知之甚少的人）描述程序的运转，说出来，这会对你理解接下来的知识点很有帮助。

大多数读者刚才可能会想或说类似这这样的东西“执行A，然后创建一个计时器等待1000毫秒，计时结束时，执行C。”，你的和这个有多相似？

你也可能会这样讲：“执行A，创建一个1000毫秒的定时器，然后执行B，当计时结束时，执行C。”这个比上面那个更加精确，你能看出区别吗？

尽管第二种说法更精确，但是两个版本在我们理解代码，以及引擎理解代码方面都不够准确。这种代沟很微妙却也很长久，也是理解回调来实现异步的缺点的关键。

我们引入一个回调函数的扩展，意味着我们允许大脑和代码运作之间存在分歧。而一旦这两者有分歧（如你所见，到目前为止，它不仅仅发生在上面这种场景），我们就会觉得代码难以理解，分析，调试以及维护。

## Sequential Brain
我相信大多数读者都听过一些人（甚至读者本人）都说过：”我可以三心二意“。“三心二意”的结果不是搞笑的（比如儿童游戏patting-head-rubbing-stomach）就是平凡的（边走路边嚼口香糖），甚至完全是危险的（边开车边发短信）。

但我们真的可以“三心二意”吗？我们真的可以同时做两件需要专注动作和思考的事情吗？我们大脑的最高水平是可以并行多线程运转吗？

答案可能让你吃惊：**或许并不能。**

我们大脑的还真不是这么构造的，我们只不过是大家都不愿承认的单任务者。我们在一个时刻真的只能思考一件事情。

我说的不是我们的无意识、潜意识和大脑自动功能，比如心跳、呼吸和眨眼。这些都是我们生存的关键，但是我们不需要故意去消耗脑力给它们。庆幸地是，当我们沉浸在一分钟15次查看社交消息里时，我们的大脑在后台（进程！）继续那些重要的任务。

说说你当前大脑里排在最前列的那个任务，于我，是写本书的这些文字，我有同时在做其它高级功能的脑部活动吗？当然没有。我很快很容易被干扰——在上几段落里有几十次！

当我们*假装*三心二意，比如试图在与友人或家人讲电话时写下点儿东西，我们实际上更像是在快速切换。也就是说，我们在两个及更多任务里快速连续来回切换，*同时*以小、快的小部分处理每一个任务。我们进行的如此之快，从外部来看，我们好像是在*并行*。

是不是听起来和异步并发事件很像（正如JS里一般发生的一样）？！如果没有，请回头看第1章！

事实上，为了将庞杂的神经学简化为我们可以在此讨论的东西：我们的大脑像事件轮询队列。

如果把我写下的每一个字母（或单词）当作一个异步事件，在这句话里有好几次机会让其他事件中断我的大脑，比如我的感觉，甚至我随机的想法。

我不会在每一次机会前都被中断并被拉到另一个“进程”里，但是经常会发生这样的事情，我的大脑几乎经常切换到不同的场景里（即“进程”），这种糟糕的感觉JS引擎一定也有吧。

### Doing Versus Planning

所以，我们的大脑可以被认为是单线程的事件轮询队列，JS引擎也是，这听起来好像很配。

但我们需要注意那些比我们所分析的更细微的地方，我们计划任务与我们大脑实际处理这些任务有可观测的大不同。

又一次，我写下这样的比喻，我此刻大略的计划是一直写，依次完成我想到的几点。我没有打算让任何中断或者非线性的活动插入进来，但是我的大脑总是一直在切换。

尽管在某种程度上来讲，我们的大脑是异步事件驱动，但我们似乎是顺序同步的计划任务。“我需要去商场，买些牛奶，然后去干洗店洗衣“。

你可能发现这种高等级的想法（计划）并不是很异步，实际上，我们一般很少刻意以事件的形式来思考。相反，我们仔细顺序地计划事情（A，然后B，然后C），假设从某种程度上有一种暂时的阻力，让B等待A。

当一个开发者写代码时，他们在计划一系列要发生的行为。如果他们够专业，他们会**仔细的计划**。“我需要把`x`的值赋给`z`，然后赋给`y`“，等等。

当我们写同步代码时，一条语句接着一条，就好像我们的待办事项：

```js
// swap `x` and `y` (via temp variable `z`)
z = x;
x = y;
y = z;
```

这三条语句是同步的，所以`x = y`等待`z = x`执行完毕，`y = z`等待`x = y`完毕，即这三条语句当前必须按照一定顺序执行，一条接着一条。幸好这里我们无需在意异步事件，否则代码很快就变得更加复杂！

所以，如果同步的大脑计划映射出同步的代码语句，那我们的大脑映射异步代码水平如何？

事实是，我们在代码里（借助回调）表达异步并不如同步大脑计划映射的那么好。

你能像下面这样来计划你的待办事项吗？

> “我需要去超市，在路上我肯定会接到一个电话，所以‘嗨，妈妈’，在她开始讲话时，我将在GPS上查找超市的地点，但是要话费几秒来加载，所以我会调小音量，所以我可以更好的听妈妈讲话，然后我意识到现在好冷，我忘记穿夹克了，无妨，继续开车和与妈妈讲电话，然后安全带响了提醒我系上安全带，所一‘啊呀，妈妈，我在系安全带，我一直都这样！’，啊，终于GPS有了导航，现在……”

上面这种我们如此计划我们的日常以及思考该做什么该按什么顺序，听起来可能很搞笑，但是这的确时我们大脑的在功能水平上的处理，记住，这不是多任务，只不过是快速的场景切换。

之所以开发者写异步事件代码很困难，尤其是只有回调这种方式，意识流的思考／计划对我们来说很反常。

我们是按步骤思考的，但是当我们从同步进入到异步时，代码中的工具（回调）却不是按步骤来的。

**这**就是为何使用回调的异步JS代码这么难创建和分析：因为这不是我们大脑做计划的套路。

**注意：** 只知道为何有些代码不生效并不意味着就知道了它真正的原理！这就是经典的“纸牌屋”比喻：“有效，但不知道原因，所以任何人都不要动它！”你可能也听说过“他人即地狱”（萨特），程序员修改了这句名言，“他人的代码就是地狱”。我确信这个：“不懂我自己的代码才是地狱”。回调就是主犯之一。

### Nested/Chained Callbacks

有这样的代码：

```js
listen( "click", function handler(evt){
	setTimeout( function request(){
		ajax( "http://some.url.1", function response(text){
			if (text == "hello") {
				handler();
			}
			else if (text == "world") {
				request();
			}
		} );
	}, 500) ;
} );
```

这种代码你应该很熟悉，我们在这里嵌套了3个函数，每一个都代表着异步中的一步（任务，“进程”）。这种代码常被称为“回调地狱“，有时也叫做“噩梦金字塔”（因为嵌套缩紧出现的三角形）。

但是“回调地狱”和嵌套／缩进没什么关系，它有更深层次的原因，我们稍后章节会详细说明。

首先，我们等待“点击”事件，然后等待定时器到期，然后等待Ajax响应，然后再来一次。

乍看之下，这段代码似乎把异步自然地映射到了顺序的大脑计划。

首先（*现在），我们：

```js
listen( "..", function handler(..){
	// ..
} );
```

然后（*后来*），我们：

```js
setTimeout( function request(..){
	// ..
}, 500) ;
```

然后（*后来*），我们：

```js
ajax( "..", function response(..){
	// ..
} );
```

最终（最后一个*后来*），我们：

```js
if ( .. ) {
	// ..
}
else ..
```

但是按照这种线性方式分析是有问题的：

首先，我们的步骤按照顺序（1，2，3然后4……）是个巧合，在真实的异步JS程序里，一定有许多其它的噪声干扰存在，这些噪声我们必须熟练的在脑中演练，当我们从一个函数跳到另一个时。在充满回调的代码里理解异步工作流不是不可能，但是很不容易，即使花费了大量的练习。

而且，还有更深层的错误，在上述示例中并不明显，我们看另一个场景（伪代码）示例：

```js
doA( function(){
	doB();

	doC( function(){
		doD();
	} )

	doE();
} );

doF();
```
尽管你们中经验丰富的人能正确的指出执行顺序，但我打赌看到它的第一眼你一定很困惑，并且花费了些脑力来识别出顺序，执行顺序如下：

* `doA()`
* `doF()`
* `doB()`
* `doC()`
* `doE()`
* `doD()`

你看到的第一眼是否得出了正确的结论？

好的，有些读者可能会觉得我函数命名不够公平，会误导人，我发誓我只是按照代码里出现的先后顺序来命名的，但是让我们再尝试：

```js
doA( function(){
	doC();

	doD( function(){
		doF();
	} )

	doE();
} );

doB();
```

现在，我按照它们的真实执行顺序进行了命名，我仍然打赌，即使这种场景你已经有了经验，也不见得有些读者会顺着`A -> B -> C -> D -> E -> F`这样的顺序，你的眼睛会在这段代码上频繁地上下跳动。

但即使所有的对你都是自然而然的，仍然有问题，你能说清楚它时是什么吗？
But even if that all comes natural to you, there's still one more hazard that could wreak havoc. Can you spot what it is?

如果`doA(..)`或者`doD(..)`并不是异步的，但我们因为眼见的是？啊哦，现在顺序又不同了，如果它俩都是同步的（也许只是有时候，取决于当时程序的条件），那么执行顺序就是`A -> C -> D -> F -> E -> B`。

你刚刚听到的微弱的声音正是众多正遇到这些问题的JS开发者的叹息。

是因为嵌套吗？它使得追踪异步流很困难？当然有几分是因为它。

但是让我们去掉上面的事件／定时／Ajax示例中的嵌套：

```js
listen( "click", handler );

function handler() {
	setTimeout( request, 500 );
}

function request(){
	ajax( "http://some.url.1", response );
}

function response(text){
	if (text == "hello") {
		handler();
	}
	else if (text == "world") {
		request();
	}
}
```

相比较前面嵌套／缩进形式，这种格式的代码更容易阅读，但是它和前面的一样都是“回调地狱”，为什么呢？

当我们顺序（线性）的分析这段代码时，我们需要从一个函数跳到另一个，基于“看“到的顺序流跳转。记住，这是为了最好示例而简化了的代码。我们都知道，真实的JS异步编程代码会很复杂，这样会把分析顺序的难度放大。

还需要注意的是：为了让步骤2，3，4按顺序执行，使用回调的唯一方式就是把步骤2硬编码在步骤1里，步骤3在步骤2里，等等。如果确实步骤2总是触发步骤3，那么硬编码就并不一定是坏事。

但是硬编码的确让代码更脆弱，导致步骤进行出错的原因不总是它。比如，如果步骤2失败了，步骤3就不会执行，也不会有步骤2的重试机制，或者去到错误处理流里，等等。

所有这些你*可以*手动硬编码进每一步的问题在于，代码重复，且没有在其它步骤或者程序里其它异步流里复用。

尽管我们的大脑可能会按顺序计划出一列任务（这样，然后这样，然后……），但是大脑事件驱动的本质让控制流的恢复／重试／获取都徒劳无功。如果你外出跑任务，但你发现购物清单落在了家里，这种没有计划外的事情并不会毁掉你的一天，大脑会这么处理这种突发事件：你回家取清单，然后回到超市。

手动硬编码回调函数（即使做了硬编码的错误处理）的脆弱本质很不优雅，一旦最后你详细列举（即预计）所有会出现的可能和分支，你的代码会变得复杂到难以维护和修改。

**这**就是“回调地狱”！嵌套／缩进只不过是现象，干扰现象罢了。

这还不够，我们还没有说到当两个或者更多的这些回调链*同时*发生时会怎样，或者当步骤3扩展为有门或锁的“并行”回调，或者……OMG，我脑仁疼，你呢！？

你还记得我们关于线性阻塞的大脑计划行为并不能映射为基于回调的异步代码的概念吗？这是使用回调的主要缺陷：它们在代码里用一种大脑为了保持同步必须挣扎的异步表述方式。

## Trust Issues
线性大脑计划与回调驱动的异步代码的不匹配仅仅是回调的部分问题。还有更需要关注的问题。我们再看一下回调函数的概念：

```js
// A
ajax( "..", function(..){
	// C
} );
// B
```

`// A`和`// B`发生在*当前*，由JS程序直接控制，但是`//C`却被推迟到*后来*发生，并且被其它部分控制——此例中的`ajax(..)`函数。一般来讲，这种不干涉的控制不会引起程序问题。

但是不要被这种低概率误导了，认为控制切换没什么大不了。事实上，这是回调驱动设计的最糟糕的问题之一。它的核心是有时`ajax(..)`（即你将回调移交给到部分）不是你写的函数，或者你不能直接控制，很多时候，它是第三方提供的功能。

当你把你程序里的一部分执行控制权移交给其它第三方时，我们称这为“控制反转”。你的代码和第三方功能之间有一个无形的“协议”——一个你期望维护的东西的集合。

### Tale of Five Callbacks

好像这并没有什么大不了的，让我来构造一个夸张场景说明一下游戏里的信任危机。

想象你是一个开发者，被分配了为一个卖高端TV网站建立电子商务结算系统的任务，你已经把不同页面的结算系统做完了，在最后一个页面，当用户点击“确认”按钮来购买TV时，你需要调用第三方的函数（由一些跟踪分析的公司提供），从而这笔交易可以被跟踪。

你注意到他们提供的好像是异步跟踪功能，可能为了实际的性能，你需要传入一个回调函数。在这个传入的函数里，最终代码会支取用户信用卡，然后显示感谢购买的页面。

这个代码可能类似这样：

```js
analytics.trackPurchase( purchaseData, function(){
	chargeCreditCard();
	displayThankyouPage();
} );
```

很简单，是吧？你写完代码，测试，都OK，然后部署到生产环境，完美！

6个月过去了没有出现问题。你甚至都已经忘记了是你写的这些代码。一天早晨上班前，你在咖啡店，正悠闲的喝着你的拿铁，忽然闹心的电话想起，你的老板让你赶紧去公司。

到公司后，你发现一位高级顾客购买一部TV，却被刷了5次卡，他当然很愤怒。客服已经官方道歉并且进行了退款，但是你的老板需要弄清楚问题起因（译者注：可怕的事故回溯时间到来了。），“我们没有测试这种情况吗？”

你完全想不起来你写的代码，但是你回过头去弄明白哪里出了问题。在翻看了一些日志后，你得出结论，唯一的解释就是，那个分析工具不知怎么的调用了5次你传入的回调，而不是1次，但他们的文档里没有关于这个的任何说明。

很挫败，你联系了他们的客服，他们和你一样吃惊。他们允诺会提交给他们的开发者，一有结果就反馈给你。第二天，你收到了一封很长的邮件，他们解释发现的问题，你迅速反映给了你的老板。

显然，分析公司的开发者开发了实验性的代码，在特定的条件下，在超时之前，会对传入的回调进行每秒一次共5次的失败重试处理。他们并没有想把这个功能部署到生产环境，但不留神，还是发布了出去，他们很抱歉。他们更进一步详细说明了他们已经确认了问题，以及他们采取了什么措施保证这种事情再也不会发生，等等。

然后嘞？

你和领导详细的商讨，但是他很不满意目前事情的状况，你也勉强同意，你们不能再*相信*他们（那些伤害过你们），你也需要找出一个能保护结算代码免受类似影响的方法。

思考再三，你实现了一些简单又特别的类似下面的代码，团队也都觉得挺好：

```js
var tracked = false;

analytics.trackPurchase( purchaseData, function(){
	if (!tracked) {
		tracked = true;
		chargeCreditCard();
		displayThankyouPage();
	}
} );
```

**注意：** 这对你来说应该很熟悉如果你看过第1章，我们创建了锁来处理并发回调问题。

但然后一个QA工程师问：“如果他们从来都没有调用回调呢？”啊哦，你们好想都没有考虑过这一点。

你决定深究一下，考虑他们调用回调时所有可能出错的情况。下面是你觉得分析工具可能会出错的点：

* 过早调用回调函数（它被追踪前）
* 过晚或者没有）调用（或者没有）
* 频繁调用（译者注：原文是too few or too many），正如你遇到的情况
* 传入你的回调函数的必要参数失败
* 淹没了任何发生的错误／异常
* ...

这会是一个让人痛苦的列表，因为它的确是。你可能慢慢觉察到这样的话你需要在你传给你不信任的分析工具的回调里创建在**每一次回调中*都需要的丑陋的特别处理逻辑。

现在，你终于有点儿明白“回调地狱”的真正意思了。

### Not Just Others' Code

有些人可能怀疑在这一点上，是否真如我所说的那样严重。也许你并没有与第三方工具打过交道。也许你使用的是迭代的API或者自己开发的库，所以它可能的行为你都知晓。

所以，思考一下：你*真的*信任你代码里理论上可控的工具？

可以这么想：大多数人都同意在一定程度上我们自己的内部函数都需要有一些针对入参的防御性检验，从而减少或阻止意外的问题。

过度信任输入：

```js
function addNumbers(x,y) {
	// + is overloaded with coercion to also be
	// string concatenation, so this operation
	// isn't strictly safe depending on what's
	// passed in.
	return x + y;
}

addNumbers( 21, 21 );	// 42
addNumbers( 21, "21" );	// "2121"
```

针对不可信输入的防御：
```js
function addNumbers(x,y) {
	// ensure numerical input
	if (typeof x != "number" || typeof y != "number") {
		throw Error( "Bad parameters" );
	}

	// if we get here, + will safely do numeric addition
	return x + y;
}

addNumbers( 21, 21 );	// 42
addNumbers( 21, "21" );	// Error: "Bad parameters"
```

或者依然安全但是更友好：
```js
function addNumbers(x,y) {
	// ensure numerical input
	x = Number( x );
	y = Number( y );

	// + will safely do numeric addition
	return x + y;
}

addNumbers( 21, 21 );	// 42
addNumbers( 21, "21" );	// 42
```

然而当你着手做时，这些检查／标准化一般都是用在函数的输入上，即使是那些我们完全信任的代码。这大略类似于地理政治上的“信任，但也要验证“原则。

所以，我们在异步回调函数的构成里也进行同样操作似乎时很合理的，不仅仅对外部代码，也对那些我们一般知道是在掌控之下的。

但是回调没有提供任何辅助手段，我们必须自己构建这种机制，因此最后我们做出一大堆在每一个异步回调里重复的样板／顶部内容。

回调最烦人的问题就是*控制反转*导致了原本可信界限的瓦解。
The most troublesome problem with callbacks is *inversion of control* leading to a complete breakdown along all those trust lines.

如果你的代码里使用了回调，尤其是使用了第三方工具的，你还没有做任何事情来缓解*控制反转*带来的问题，那么你的代码目前*是有*bug的，即使还没有暴露造成损失。但潜在的bug也是bug啊。

简直讨厌！

## Trying to Save Callbacks

有一些改进版的回调设计已经尝试处理一些（不是所有！）我们前面看到的信任危机。这是防止回调模式自曝的勇敢但必然的努力。

比如，考虑更优雅的错误处理，一些API设计提供了拆分回调的功能（一个是成功通知，一个给错误通知）：

```js
function success(data) {
	console.log( data );
}

function failure(err) {
	console.error( err );
}

ajax( "http://some.url.1", success, failure );
```

这种API的设计，一般`failure()`的错误处理时可选的，如果不提供默认假定你想要那些错误被吞没。呃。

**注意：** 这种回调拆分设计就是ES6里面的Promise API采用的。我们在下一章会详解ES6的Promise。

另一种常见回调模式是“错误优先样式”（有时叫做“Node范儿”，缘于所有Node.js API的惯例），第一个参数被保留提供给错误处理（如果有）。如果成功，这个参数会被清空或置伪（其余顺序的参数是正确的数据），但是如有错误结果被发现，那么第一个参数被设置（一般不传入别的东西）：

```js
function response(err,data) {
	// error?
	if (err) {
		console.error( err );
	}
	// otherwise, assume success
	else {
		console.log( data );
	}
}

ajax( "http://some.url.1", response );
```

在两种场景下，几个东西需要被观测。
In both of these cases, several things should be observed.

首先，信任危机问题没有被看起来那样被解决，没有任何关于阻止或过滤不必要的重复激活的东西，而且，事情变得更糟了，因为你可能会得到成功和失败两个信号，或者一个都没有，你依然需要在这些条件下写代码。

而且，不要错过这是一个可以使用的标准模式这个事实，如果没有重用那你绝对会更冗余的和样板式的，所以你将会厌烦给你应用中的每一个异步回调都加上那些东西。

那么直接信任问题永远不会被调用会怎样？如果你在意（而且应该！），你可能需要建立定时器来取消事件。你可以创建一个工具（只显示概念验证）来帮助你实现：

```js
function timeoutify(fn,delay) {
	var intv = setTimeout( function(){
			intv = null;
			fn( new Error( "Timeout!" ) );
		}, delay )
	;

	return function() {
		// timeout hasn't happened yet?
		if (intv) {
			clearTimeout( intv );
			fn.apply( this, [ null ].concat( [].slice.call( arguments ) ) );
		}
	};
}
```

下面是使用方式：

```js
// using "error-first style" callback design
function foo(err,data) {
	if (err) {
		console.error( err );
	}
	else {
		console.log( data );
	}
}

ajax( "http://some.url.1", timeoutify( foo, 500 ) );
```

另一个信任问题是”过早“，在应用专业来讲，就是在必要关键任务完成之前就调用。但更一般地，在工具使用时问题很明显，你提供给的回调要么*现在*（同步地）要么被*后来*（异步）调用。

这种同步还是异步的不确定性总是会导致问题定位困难。一些圈子里，虚构的诱导精神错乱的怪物被叫做Zalgo，用来描述同步／异步噩梦。“不要释放Zalgo！”是最常见的呼吁，因为这出现了一些合理的建议：异步的触发回调，即使它是在事件轮询队列的下一个“立即”被调用者，这样所有的回调都是意料中的异步发生。

**注意：** 了解更多关于Zalgo，可以查看Oren Golan的"Don't Release Zalgo!" (https://github.com/oren/oren.github.io/blob/master/posts/zalgo.md)，以及Isaac Z. Schlueter的"Designing APIs for Asynchrony" (http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony)。

考虑：

```js
function result(data) {
	console.log( a );
}

var a = 0;

ajax( "..pre-cached-url..", result );
a++;
```

这段代码会打印`0`（同步触发）还是`1`（异步回调触发），取决于……条件。

你会看到Zalgo的不可预测性怎样快速的威胁JS程序，所以那个听起来蠢蠢的“绝不要放出Zalgo“不可避免的很常见且很靠谱，永远都使用异步。

如果你不知道到底API会不会总是异步执行的？你可以创造一个类似概念验证`asyncify(..)`的工具：

```js
function asyncify(fn) {
	var orig_fn = fn,
		intv = setTimeout( function(){
			intv = null;
			if (fn) fn();
		}, 0 )
	;

	fn = null;

	return function() {
		// firing too quickly, before `intv` timer has fired to
		// indicate async turn has passed?
		if (intv) {
			fn = orig_fn.bind.apply(
				orig_fn,
				// add the wrapper's `this` to the `bind(..)`
				// call parameters, as well as currying any
				// passed in parameters
				[this].concat( [].slice.call( arguments ) )
			);
		}
		// already async
		else {
			// invoke original function
			orig_fn.apply( this, arguments );
		}
	};
}
```

你这样使用`asyncify(..)`：

```js
function result(data) {
	console.log( a );
}

var a = 0;

ajax( "..pre-cached-url..", asyncify( result ) );
a++;
```

无论Ajax请求是在缓存或解析阶段尝试调用回调，还是在传输上获取从而异步的完成后续任务，这段代码总是会输出`1`而不是`0`——`result(..)`只能异步的被触发，别无所择，这样，`a++`有机会在`result(..)`前执行。

哦，另一个信任问题“解决了！”，但是很低效，着让你的代码很臃肿。

这就是关于回调源源不断的故事。它们可以做几乎任何你想要的事情，但是你必须做好准备去努力理解它，并且经常这种努力超出了你能够或者你应该花在这种代码分析的努力。

你可能觉得你很需要一种内建的API或者其它语言机制来处理这些问题。终于ES6带着给力的解决方案登上了舞台，欲知详情，下回分解！

## Review

回调是JS异步的基础，但是他们还不足以作为JS异步编程的成熟演进模型。

首先，我们的大脑是线性、阻塞、单线程的方式来计划事情的，但是回调表达异步流却是一种非线性、非顺序的方式，这让分析这种代码变得很艰难，难以分析的代码就是那些导致糟糕bug的坏代码。

我们需要一种能以更同步、阻塞、线性的方式来表达异步，就像我们的大脑那样。

然后，也是更重要的一点，回调因为把控制权交给了另一方（通常是不受你控制的第三方工具）来触发你的程序*继续*（运行），所以会受*控制反转*的影响。控制权的转移导致一些信任问题，比如是否回调被调用次数超过了我们的预期。

创建专门解决这种信任问题的逻辑时可能的，但是却超过了成本，并且会产生很多冗余的、难以理解的维护代码，同时还会有那些直到你明显被坑才会发现是因为没有充分规避危害的bug。

我们需要一个通用于**所有信任问题**的解决方案，一个可以被许多回调重用而不需要再在开头创建引用的方案。

我们需要一些比回调更优雅的东西，虽然回调已广泛服务于大家，但是JS的*未来*呼吁更成熟和强大的异步模式。接下来几章会深入研究这些新兴的演进。
