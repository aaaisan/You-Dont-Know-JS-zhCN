# You Don't Know JS: Async & Performance
# Chapter 2: Callbacks

在第1章，我们探索了JS编程里的异步概念。我们着重于理解单线程下的事件轮询队列驱动事件（异步函数调用）。我们也探索了不同并发模式，它们解释了*同步*事件运行链和“进程”（任务、函数调用等）的关系。

第1章的所有例子都使用函数作为个人的最小的的操作单元，即函数中的语句是按照预期的顺序执行（编译器级别的上一层），但是在函数顺序级别，事件（即异步函数调用）发生的顺序是可变的。

在所有的场景下，函数被作为一个“回调”，因为它的角色是事件轮训“召回”到程序里的目标，只要它在队列里就会被处理。

你也确实看到了，回调是目前为止JS编程里最普通的异步表达和管理方式，的确，回调是这门语言里大多数异步模式的基础。

无数JS程序，即使是精细又复杂的那些，也都是把回调当作异步基础的（当然包括我们在第1章里探索的并发交互模式），回调函数是JS异步主力，并且工作的很好。

除了……回调并不是没有缺点，许多开发者激动于更好的异步模式*promises*（双关语！），但是如果你不理解它的概念和原理你不能有效的使用任何概念。

这一章，我们会深入探索其中几个，从而解释为何更成熟的异步模式是必要的。

## Continuations

我们回到第1章开始的异步回调例子，为了突出一点，我稍微修改了一下：

```js
// A
ajax( "..", function(..){
	// C
} );
// B
```

`// A`和`// B`代表程序的第一部分（即*当前*），`//C`代表程序的第二部分（即*后来*）。第一部分立刻执行，然后中间有一段“暂停”，未来某时刻，如果Ajax调用有了响应，那么程序会从刚才暂停的地方*继续*完成第二部分的执行。

换句话说，回调函数包裹或封装了*继续*程序，我们让代码更简单一些：

```js
// A
setTimeout( function(){
	// C
}, 1000 );
// B
```

停下来想一想，你会如何（给那些对JS运行原理知之甚少的人）描述程序的运转，说出来，这会对你理解接下来的知识点很有帮助。

大多数读者刚才可能会想或说类似这这样的东西“执行A，然后创建一个计时器等待1000毫秒，计时结束时，执行C。”，你的和这个有多相似？

你也可能会这样讲：“执行A，创建一个1000毫秒的定时器，然后执行B，当计时结束时，执行C。”这个比上面那个更加精确，你能看出区别吗？

尽管第二种说法更精确，但是两个版本在我们理解代码，以及引擎理解代码方面都不够准确。
